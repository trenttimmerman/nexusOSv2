-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Products Table
create table if not exists products (
  id text primary key, -- Keeping text to match current UUIDs generated by frontend, or we can switch to uuid default gen_random_uuid()
  name text not null,
  description text,
  price numeric,
  compare_at_price numeric,
  image text,
  images jsonb default '[]'::jsonb,
  category text,
  tags text[],
  sku text,
  stock integer default 0,
  track_inventory boolean default true,
  has_variants boolean default false,
  variant_options jsonb default '[]'::jsonb,
  variants jsonb default '[]'::jsonb,
  seo jsonb default '{}'::jsonb,
  status text default 'active',
  template text,
  allow_customization boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Pages Table
create table if not exists pages (
  id text primary key,
  title text not null,
  slug text not null unique,
  type text default 'custom',
  content text, -- Deprecated but kept for compatibility
  blocks jsonb default '[]'::jsonb,
  created_at timestamptz default now()
);

-- Media Assets Table
create table if not exists media_assets (
  id text primary key,
  url text not null,
  name text not null,
  type text not null,
  size numeric,
  created_at timestamptz default now()
);

-- Campaigns Table
create table if not exists campaigns (
  id text primary key,
  name text not null,
  type text not null,
  status text default 'draft',
  subject text,
  content text,
  audience text,
  scheduled_for timestamptz,
  sent_at timestamptz,
  stats jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

-- Store Config Table (Single Row)
create table if not exists store_config (
  id integer primary key default 1,
  name text default 'Nexus Store',
  currency text default 'USD',
  header_style text default 'canvas',
  header_data jsonb default '{}'::jsonb,
  hero_style text default 'impact',
  product_card_style text default 'classic',
  footer_style text default 'columns',
  scrollbar_style text default 'native',
  primary_color text default '#000000',
  logo_url text,
  logo_height integer default 32,
  updated_at timestamptz default now(),
  constraint single_row check (id = 1)
);

-- Insert default config if not exists
insert into store_config (id, name)
values (1, 'Nexus Store')
on conflict (id) do nothing;

-- Enable Row Level Security (RLS)
alter table products enable row level security;
alter table pages enable row level security;
alter table media_assets enable row level security;
alter table campaigns enable row level security;
alter table store_config enable row level security;

-- Create Policies (Public Read / Anon Write for Demo Purposes)
-- IN PRODUCTION: You should restrict Write access to authenticated users only.
create policy "Public Read Products" on products for select using (true);
create policy "Public Write Products" on products for insert with check (true);
create policy "Public Update Products" on products for update using (true);
create policy "Public Delete Products" on products for delete using (true);

create policy "Public Read Pages" on pages for select using (true);
create policy "Public Write Pages" on pages for insert with check (true);
create policy "Public Update Pages" on pages for update using (true);
create policy "Public Delete Pages" on pages for delete using (true);

create policy "Public Read Media" on media_assets for select using (true);
create policy "Public Write Media" on media_assets for insert with check (true);
create policy "Public Update Media" on media_assets for update using (true);
create policy "Public Delete Media" on media_assets for delete using (true);

create policy "Public Read Campaigns" on campaigns for select using (true);
create policy "Public Write Campaigns" on campaigns for insert with check (true);
create policy "Public Update Campaigns" on campaigns for update using (true);
create policy "Public Delete Campaigns" on campaigns for delete using (true);

create policy "Public Read Config" on store_config for select using (true);
create policy "Public Update Config" on store_config for update using (true);
-- Create Stores Table
create table if not exists stores (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  slug text unique not null,
  created_at timestamptz default now()
);

-- Create Profiles Table (Links Auth Users to Stores)
create table if not exists profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  store_id uuid references stores(id) on delete cascade,
  role text default 'admin',
  created_at timestamptz default now()
);

-- Enable RLS on new tables
alter table stores enable row level security;
alter table profiles enable row level security;

-- Add store_id to existing tables
alter table products add column if not exists store_id uuid references stores(id) on delete cascade;
alter table pages add column if not exists store_id uuid references stores(id) on delete cascade;
alter table media_assets add column if not exists store_id uuid references stores(id) on delete cascade;
alter table campaigns add column if not exists store_id uuid references stores(id) on delete cascade;

-- Update store_config to be multi-tenant
-- First, drop the single row constraint
alter table store_config drop constraint if exists single_row;
-- Add store_id
alter table store_config add column if not exists store_id uuid references stores(id) on delete cascade;
-- Make store_id unique (one config per store)
alter table store_config add constraint unique_store_config unique (store_id);

-- RLS Policies for Multi-Tenancy

-- Profiles: Users can read their own profile
create policy "Users can read own profile" on profiles
  for select using (auth.uid() = id);

-- Stores: Users can read their own store
create policy "Users can read own store" on stores
  for select using (id in (select store_id from profiles where id = auth.uid()));

-- Stores: Public read access for storefront visitors
create policy "Public stores are viewable by everyone" on stores
  for select using (true);

-- Products: Tenant Isolation
drop policy if exists "Public Read Products" on products;
drop policy if exists "Public Write Products" on products;
drop policy if exists "Public Update Products" on products;
drop policy if exists "Public Delete Products" on products;

create policy "Tenant Read Products" on products
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Products" on products
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Products" on products
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Delete Products" on products
  for delete using (store_id in (select store_id from profiles where id = auth.uid()));

-- Pages: Tenant Isolation
drop policy if exists "Public Read Pages" on pages;
drop policy if exists "Public Write Pages" on pages;
drop policy if exists "Public Update Pages" on pages;
drop policy if exists "Public Delete Pages" on pages;

create policy "Tenant Read Pages" on pages
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Pages" on pages
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Pages" on pages
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Delete Pages" on pages
  for delete using (store_id in (select store_id from profiles where id = auth.uid()));

-- Media: Tenant Isolation
drop policy if exists "Public Read Media" on media_assets;
drop policy if exists "Public Write Media" on media_assets;
drop policy if exists "Public Update Media" on media_assets;
drop policy if exists "Public Delete Media" on media_assets;

create policy "Tenant Read Media" on media_assets
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Media" on media_assets
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Media" on media_assets
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Delete Media" on media_assets
  for delete using (store_id in (select store_id from profiles where id = auth.uid()));

-- Campaigns: Tenant Isolation
drop policy if exists "Public Read Campaigns" on campaigns;
drop policy if exists "Public Write Campaigns" on campaigns;
drop policy if exists "Public Update Campaigns" on campaigns;
drop policy if exists "Public Delete Campaigns" on campaigns;

create policy "Tenant Read Campaigns" on campaigns
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Campaigns" on campaigns
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Campaigns" on campaigns
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Delete Campaigns" on campaigns
  for delete using (store_id in (select store_id from profiles where id = auth.uid()));

-- Store Config: Tenant Isolation
drop policy if exists "Public Read Config" on store_config;
drop policy if exists "Public Update Config" on store_config;

create policy "Tenant Read Config" on store_config
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Config" on store_config
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Config" on store_config
  for update using (store_id in (select store_id from profiles where id = auth.uid()));
-- Update RLS policies to allow superuser access

-- Helper function to check if user is superuser
create or replace function is_superuser()
returns boolean as $$
begin
  return exists (
    select 1 from profiles
    where id = auth.uid()
    and role = 'superuser'
  );
end;
$$ language plpgsql security definer;

-- Update Policies for Products
drop policy if exists "Tenant Read Products" on products;
create policy "Tenant Read Products" on products
  for select using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Insert Products" on products;
create policy "Tenant Insert Products" on products
  for insert with check (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Update Products" on products;
create policy "Tenant Update Products" on products
  for update using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Delete Products" on products;
create policy "Tenant Delete Products" on products
  for delete using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

-- Update Policies for Pages
drop policy if exists "Tenant Read Pages" on pages;
create policy "Tenant Read Pages" on pages
  for select using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Insert Pages" on pages;
create policy "Tenant Insert Pages" on pages
  for insert with check (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Update Pages" on pages;
create policy "Tenant Update Pages" on pages
  for update using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Delete Pages" on pages;
create policy "Tenant Delete Pages" on pages
  for delete using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

-- Update Policies for Media Assets
drop policy if exists "Tenant Read Media" on media_assets;
create policy "Tenant Read Media" on media_assets
  for select using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Insert Media" on media_assets;
create policy "Tenant Insert Media" on media_assets
  for insert with check (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Update Media" on media_assets;
create policy "Tenant Update Media" on media_assets
  for update using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Delete Media" on media_assets;
create policy "Tenant Delete Media" on media_assets
  for delete using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

-- Update Policies for Campaigns
drop policy if exists "Tenant Read Campaigns" on campaigns;
create policy "Tenant Read Campaigns" on campaigns
  for select using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Insert Campaigns" on campaigns;
create policy "Tenant Insert Campaigns" on campaigns
  for insert with check (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Update Campaigns" on campaigns;
create policy "Tenant Update Campaigns" on campaigns
  for update using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Delete Campaigns" on campaigns;
create policy "Tenant Delete Campaigns" on campaigns
  for delete using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

-- Update Policies for Store Config
drop policy if exists "Tenant Read Config" on store_config;
create policy "Tenant Read Config" on store_config
  for select using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Insert Config" on store_config;
create policy "Tenant Insert Config" on store_config
  for insert with check (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

drop policy if exists "Tenant Update Config" on store_config;
create policy "Tenant Update Config" on store_config
  for update using (
    store_id in (select store_id from profiles where id = auth.uid())
    or is_superuser()
  );

-- Set trent@3thirty3.ca as superuser and assign to Demo Store
DO $$
DECLARE
  target_user_id uuid;
  demo_store_id uuid;
BEGIN
  -- Find the user ID from auth.users
  SELECT id INTO target_user_id FROM auth.users WHERE email = 'trent@3thirty3.ca';
  
  -- Create or Get Demo Store
  INSERT INTO stores (name, slug)
  VALUES ('Demo Store', 'demo-store')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id INTO demo_store_id;

  IF target_user_id IS NOT NULL THEN
    -- Update or Insert into profiles
    INSERT INTO profiles (id, store_id, role)
    VALUES (target_user_id, demo_store_id, 'superuser')
    ON CONFLICT (id) DO UPDATE
    SET role = 'superuser',
        store_id = demo_store_id;
  END IF;
END $$;
-- Ensure trent@3thirty3.ca is superuser and assigned to Demo Store
-- This is a re-run to ensure it catches the user created after the initial migration
DO $$
DECLARE
  target_user_id uuid;
  demo_store_id uuid;
BEGIN
  -- Find the user ID from auth.users
  SELECT id INTO target_user_id FROM auth.users WHERE email = 'trent@3thirty3.ca';
  
  -- Create or Get Demo Store
  INSERT INTO stores (name, slug)
  VALUES ('Demo Store', 'demo-store')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id INTO demo_store_id;

  IF target_user_id IS NOT NULL THEN
    -- Update or Insert into profiles
    INSERT INTO profiles (id, store_id, role)
    VALUES (target_user_id, demo_store_id, 'superuser')
    ON CONFLICT (id) DO UPDATE
    SET role = 'superuser',
        store_id = demo_store_id;
  END IF;
END $$;-- Enable UUID extension if not already enabled
create extension if not exists "uuid-ossp";

-- 1. Customers Table
create table if not exists customers (
  id uuid primary key default uuid_generate_v4(),
  store_id uuid references stores(id) on delete cascade,
  email text not null,
  first_name text,
  last_name text,
  phone text,
  created_at timestamptz default now()
);

-- 2. Orders Table
create table if not exists orders (
  id uuid primary key default uuid_generate_v4(),
  store_id uuid references stores(id) on delete cascade,
  customer_id uuid references customers(id) on delete set null,
  total_amount numeric default 0,
  currency text default 'USD',
  status text default 'pending', -- pending, paid, fulfilled, cancelled, refunded
  payment_status text default 'unpaid',
  created_at timestamptz default now()
);

-- 3. Order Items Table
create table if not exists order_items (
  id uuid primary key default uuid_generate_v4(),
  order_id uuid references orders(id) on delete cascade,
  product_id text, -- referencing products.id (text)
  quantity integer default 1,
  price_at_purchase numeric,
  created_at timestamptz default now()
);

-- 4. Subscriptions Table (SaaS Layer)
create table if not exists subscriptions (
  id uuid primary key default uuid_generate_v4(),
  store_id uuid references stores(id) on delete cascade unique, -- One active subscription per store
  plan_id text default 'free', -- free, pro, enterprise
  status text default 'active', -- active, past_due, cancelled, trialing
  current_period_start timestamptz default now(),
  current_period_end timestamptz,
  cancel_at_period_end boolean default false,
  created_at timestamptz default now()
);

-- Enable Row Level Security
alter table customers enable row level security;
alter table orders enable row level security;
alter table order_items enable row level security;
alter table subscriptions enable row level security;

-- RLS Policies: Tenant Isolation

-- Customers
create policy "Tenant Read Customers" on customers
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Customers" on customers
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Customers" on customers
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

-- Orders
create policy "Tenant Read Orders" on orders
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Orders" on orders
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Orders" on orders
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

-- Order Items
create policy "Tenant Read Order Items" on order_items
  for select using (order_id in (select id from orders where store_id in (select store_id from profiles where id = auth.uid())));

create policy "Tenant Insert Order Items" on order_items
  for insert with check (order_id in (select id from orders where store_id in (select store_id from profiles where id = auth.uid())));

-- Subscriptions
-- Tenants can read their own subscription
create policy "Tenant Read Own Subscription" on subscriptions
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

-- Only Superusers can update subscriptions (This logic might need a specific superuser check function, 
-- but for now we'll allow reading. Writing should be restricted to system/webhooks or superusers).
-- We'll add a policy for Superusers to read ALL subscriptions.

create policy "Superuser Read All Subscriptions" on subscriptions
  for select using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'superuser'
    )
  );

create policy "Superuser Update Subscriptions" on subscriptions
  for update using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'superuser'
    )
  );

create policy "Superuser Insert Subscriptions" on subscriptions
  for insert with check (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'superuser'
    )
  );
-- Function to check if the current user is a superuser
create or replace function public.is_superuser()
returns boolean as $$
begin
  return exists (
    select 1 from public.profiles
    where id = auth.uid()
    and role = 'superuser'
  );
end;
$$ language plpgsql security definer;

-- Grant execute to authenticated users
grant execute on function public.is_superuser to authenticated;

-- Update RLS Policies to allow Superuser Global Access

-- Helper macro for policies (conceptually)
-- We need to update existing policies or add new ones. 
-- Adding new "OR" policies is often cleaner than modifying complex existing ones.

-- PRODUCTS
create policy "Superuser Read All Products" on products
  for select using (public.is_superuser());

create policy "Superuser Write All Products" on products
  for insert with check (public.is_superuser());

create policy "Superuser Update All Products" on products
  for update using (public.is_superuser());

create policy "Superuser Delete All Products" on products
  for delete using (public.is_superuser());

-- PAGES
create policy "Superuser Read All Pages" on pages
  for select using (public.is_superuser());

create policy "Superuser Write All Pages" on pages
  for insert with check (public.is_superuser());

create policy "Superuser Update All Pages" on pages
  for update using (public.is_superuser());

create policy "Superuser Delete All Pages" on pages
  for delete using (public.is_superuser());

-- MEDIA ASSETS
create policy "Superuser Read All Media" on media_assets
  for select using (public.is_superuser());

create policy "Superuser Write All Media" on media_assets
  for insert with check (public.is_superuser());

create policy "Superuser Update All Media" on media_assets
  for update using (public.is_superuser());

create policy "Superuser Delete All Media" on media_assets
  for delete using (public.is_superuser());

-- CAMPAIGNS
create policy "Superuser Read All Campaigns" on campaigns
  for select using (public.is_superuser());

create policy "Superuser Write All Campaigns" on campaigns
  for insert with check (public.is_superuser());

create policy "Superuser Update All Campaigns" on campaigns
  for update using (public.is_superuser());

create policy "Superuser Delete All Campaigns" on campaigns
  for delete using (public.is_superuser());

-- STORE CONFIG
create policy "Superuser Read All Config" on store_config
  for select using (public.is_superuser());

create policy "Superuser Write All Config" on store_config
  for insert with check (public.is_superuser());

create policy "Superuser Update All Config" on store_config
  for update using (public.is_superuser());

-- CUSTOMERS
create policy "Superuser Read All Customers" on customers
  for select using (public.is_superuser());

create policy "Superuser Write All Customers" on customers
  for insert with check (public.is_superuser());

create policy "Superuser Update All Customers" on customers
  for update using (public.is_superuser());

-- ORDERS
create policy "Superuser Read All Orders" on orders
  for select using (public.is_superuser());

create policy "Superuser Write All Orders" on orders
  for insert with check (public.is_superuser());

create policy "Superuser Update All Orders" on orders
  for update using (public.is_superuser());

-- ORDER ITEMS
create policy "Superuser Read All Order Items" on order_items
  for select using (public.is_superuser());

create policy "Superuser Write All Order Items" on order_items
  for insert with check (public.is_superuser());

-- STORES (Allow Superuser to create/edit stores)
create policy "Superuser Read All Stores" on stores
  for select using (public.is_superuser());

create policy "Superuser Write All Stores" on stores
  for insert with check (public.is_superuser());

create policy "Superuser Update All Stores" on stores
  for update using (public.is_superuser());

create policy "Superuser Delete All Stores" on stores
  for delete using (public.is_superuser());

-- PROFILES (Allow Superuser to see all profiles)
create policy "Superuser Read All Profiles" on profiles
  for select using (public.is_superuser());

create policy "Superuser Update All Profiles" on profiles
  for update using (public.is_superuser());
-- Add auth_user_id to customers table to link with Supabase Auth
alter table customers add column if not exists auth_user_id uuid references auth.users(id) on delete set null;

-- Add index for performance
create index if not exists idx_customers_auth_user_id on customers(auth_user_id);

-- RLS Policies for Customers

-- 1. Customers can read their own profile
create policy "Customer Read Own Data" on customers
  for select using (auth.uid() = auth_user_id);

-- 2. Customers can update their own profile
create policy "Customer Update Own Data" on customers
  for update using (auth.uid() = auth_user_id);

-- 3. Customers can read their own orders
create policy "Customer Read Own Orders" on orders
  for select using (
    customer_id in (
      select id from customers where auth_user_id = auth.uid()
    )
  );

-- 4. Customers can read their own order items
create policy "Customer Read Own Order Items" on order_items
  for select using (
    order_id in (
      select id from orders where customer_id in (
        select id from customers where auth_user_id = auth.uid()
      )
    )
  );

-- 5. Allow authenticated users to insert a customer record (for signup)
-- We need to ensure they can only insert a record for themselves
create policy "Customer Insert Own Data" on customers
  for insert with check (auth.uid() = auth_user_id);
-- Fix Superuser Access
-- This migration will run on deployment and attempt to fix the superuser role for 'trent@3thirty3.ca'
-- It also ensures a Demo Store exists.

-- 0. Fix store_config id to be auto-incrementing
-- The initial migration set default id=1, which causes conflicts for multi-tenant setups.
DO $$
BEGIN
    -- Create sequence if not exists
    CREATE SEQUENCE IF NOT EXISTS store_config_id_seq;
    
    -- Sync sequence to max id
    PERFORM setval('store_config_id_seq', COALESCE((SELECT MAX(id) FROM store_config), 0) + 1, false);
    
    -- Set new default
    ALTER TABLE store_config ALTER COLUMN id SET DEFAULT nextval('store_config_id_seq');
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Schema fix for store_config might have already been applied: %', SQLERRM;
END $$;

DO $$
DECLARE
  target_user_id uuid;
  demo_store_id uuid;
BEGIN
  -- 1. Get the user ID (if exists)
  SELECT id INTO target_user_id FROM auth.users WHERE email = 'trent@3thirty3.ca';

  -- 2. Ensure Demo Store exists
  INSERT INTO stores (name, slug)
  VALUES ('Demo Store', 'demo-store')
  ON CONFLICT (slug) DO UPDATE SET name = EXCLUDED.name
  RETURNING id INTO demo_store_id;

  -- 3. If user exists, make them superuser
  IF target_user_id IS NOT NULL THEN
    INSERT INTO profiles (id, store_id, role)
    VALUES (target_user_id, demo_store_id, 'superuser')
    ON CONFLICT (id) DO UPDATE
    SET role = 'superuser',
        store_id = demo_store_id;

    RAISE NOTICE 'User trent@3thirty3.ca promoted to superuser.';
  ELSE
    RAISE NOTICE 'User trent@3thirty3.ca not found. Please sign up first.';
  END IF;

  -- 4. Ensure Store Config exists for Demo Store
  INSERT INTO store_config (store_id, name, currency, header_style, hero_style, product_card_style, footer_style)
  VALUES (demo_store_id, 'Demo Store', 'USD', 'minimal', 'split', 'minimal', 'minimal')
  ON CONFLICT (store_id) DO NOTHING;

  -- 5. Ensure Subscription exists for Demo Store
  INSERT INTO subscriptions (store_id, plan_id, status)
  VALUES (demo_store_id, 'enterprise', 'active')
  ON CONFLICT (store_id) DO NOTHING;

END $$;
-- Allow public to create orders
DROP POLICY IF EXISTS "Tenant Insert Orders" ON orders;
CREATE POLICY "Public Insert Orders" ON orders FOR INSERT WITH CHECK (true);

-- Allow public to create order items
DROP POLICY IF EXISTS "Tenant Insert Order Items" ON order_items;
CREATE POLICY "Public Insert Order Items" ON order_items FOR INSERT WITH CHECK (true);

-- Allow public to create customers (for guest checkout)
DROP POLICY IF EXISTS "Tenant Insert Customers" ON customers;
CREATE POLICY "Public Insert Customers" ON customers FOR INSERT WITH CHECK (true);

-- Allow public to read products (Storefront needs this!)
DROP POLICY IF EXISTS "Tenant Read Products" ON products;
CREATE POLICY "Public Read Products" ON products FOR SELECT USING (true);

-- Allow public to read store config
DROP POLICY IF EXISTS "Tenant Read Config" ON store_config;
CREATE POLICY "Public Read Config" ON store_config FOR SELECT USING (true);

-- Allow public to read pages
DROP POLICY IF EXISTS "Tenant Read Pages" ON pages;
CREATE POLICY "Public Read Pages" ON pages FOR SELECT USING (true);

-- Allow public to read media
DROP POLICY IF EXISTS "Tenant Read Media" ON media_assets;
CREATE POLICY "Public Read Media" ON media_assets FOR SELECT USING (true);
-- Function to decrement stock safely
-- This function runs with SECURITY DEFINER, meaning it bypasses RLS.
-- This allows public users (guests) to decrement stock without giving them full update access to the products table.

create or replace function decrement_stock(product_id uuid, quantity_to_decrement integer)
returns void
language plpgsql
security definer
as $$
begin
  update products
  set stock = stock - quantity_to_decrement
  where id = product_id
  and stock >= quantity_to_decrement; -- Prevent negative stock
end;
$$;

-- Add shipping address columns to orders table
alter table orders 
add column if not exists shipping_address_line1 text,
add column if not exists shipping_city text,
add column if not exists shipping_postal_code text,
add column if not exists shipping_country text default 'US';

-- Also add phone to orders just in case it differs from customer profile
alter table orders
add column if not exists customer_phone text;

-- Add customer_email snapshot to orders (good practice in case customer changes email later)
alter table orders
add column if not exists customer_email text;

-- Secure Customer Inserts
-- Drop the overly permissive public policy
DROP POLICY IF EXISTS "Public Insert Customers" ON customers;

-- Create a new policy that allows:
-- 1. Guests (anon) to insert customers with NO auth_user_id
-- 2. Authenticated users to insert customers with THEIR OWN auth_user_id
-- 3. Authenticated users to insert customers with NO auth_user_id (e.g. admin creating a manual customer? No, admins use different policies usually, but for storefront this is fine)

CREATE POLICY "Secure Public Insert Customers" ON customers
FOR INSERT WITH CHECK (
  (auth.role() = 'anon' AND auth_user_id IS NULL) OR
  (auth.role() = 'authenticated' AND (auth_user_id IS NULL OR auth_user_id = auth.uid()))
);

-- Note: We keep "Customer Insert Own Data" from migration 06? 
-- Migration 06 had: create policy "Customer Insert Own Data" on customers for insert with check (auth.uid() = auth_user_id);
-- That one is redundant if we have this new one, but it doesn't hurt (OR logic).
-- Actually, migration 08 dropped "Tenant Insert Customers" but didn't drop "Customer Insert Own Data".
-- So "Customer Insert Own Data" is still active.
-- The new policy covers the Guest case.


-- Add foreign key from order_items.product_id to products.id
-- This enables Supabase to join these tables in queries

ALTER TABLE order_items
ADD CONSTRAINT fk_order_items_products
FOREIGN KEY (product_id)
REFERENCES products (id)
ON DELETE SET NULL; 
-- If a product is deleted, we keep the order item but product_id becomes null? 
-- Or maybe we want to keep the ID but just lose the link?
-- Actually, products are rarely hard deleted in e-commerce, usually soft deleted (status=archived).
-- But if they are hard deleted, we probably still want the history.
-- However, standard FK behavior prevents deletion of product if order_items exist.
-- Let's use SET NULL for now to be safe, or NO ACTION (default) which prevents deletion.
-- Given we want to preserve order history, preventing deletion of products that have been sold is good practice.
-- But for this prototype, let's just add the FK.

-- Note: If there are existing order_items with product_ids that don't exist in products table, this will fail.
-- Since we just started, it should be fine.

-- 1. Create Store Secrets Table (For sensitive keys)
create table if not exists store_secrets (
  id uuid primary key default uuid_generate_v4(),
  store_id uuid references stores(id) on delete cascade unique,
  stripe_secret_key text,
  paypal_client_secret text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Enable RLS
alter table store_secrets enable row level security;

-- RLS Policies for Store Secrets
-- Only the tenant owner (profile linked to store) can view/edit secrets
create policy "Tenant Read Secrets" on store_secrets
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Insert Secrets" on store_secrets
  for insert with check (store_id in (select store_id from profiles where id = auth.uid()));

create policy "Tenant Update Secrets" on store_secrets
  for update using (store_id in (select store_id from profiles where id = auth.uid()));

-- 2. Update Store Config (For public keys and settings)
alter table store_config
add column if not exists payment_provider text default 'manual', -- 'stripe', 'paypal', 'manual'
add column if not exists stripe_publishable_key text,
add column if not exists paypal_client_id text;

-- 3. Create Payment Transactions Table (To track payment attempts)
create table if not exists payments (
  id uuid primary key default uuid_generate_v4(),
  store_id uuid references stores(id) on delete cascade,
  order_id uuid references orders(id) on delete cascade,
  provider text not null, -- 'stripe', 'paypal'
  provider_transaction_id text,
  amount numeric not null,
  currency text default 'USD',
  status text default 'pending', -- 'pending', 'succeeded', 'failed'
  metadata jsonb default '{}'::jsonb,
  created_at timestamptz default now()
);

alter table payments enable row level security;

-- RLS for Payments
-- Tenants can see payments for their store
create policy "Tenant Read Payments" on payments
  for select using (store_id in (select store_id from profiles where id = auth.uid()));

-- Public (Checkout) can insert payments (initiate)
-- Actually, usually payments are created by the backend (Edge Function) or via webhook.
-- But for client-side initiation (like PayPal buttons), we might need insert.
-- Let's allow authenticated users (customers) to read their own payments?
create policy "Customer Read Own Payments" on payments
  for select using (
    order_id in (select id from orders where customer_id in (select id from customers where auth_user_id = auth.uid()))
  );


-- Add Square and Wallet config to store_config
alter table store_config
add column if not exists square_application_id text,
add column if not exists square_location_id text,
add column if not exists enable_apple_pay boolean default false,
add column if not exists enable_google_pay boolean default false;

-- Add Square secret to store_secrets
alter table store_secrets
add column if not exists square_access_token text;
-- Create a public storage bucket for media
INSERT INTO storage.buckets (id, name, public)
VALUES ('media', 'media', true)
ON CONFLICT (id) DO NOTHING;

-- Policy to allow public read access
CREATE POLICY "Public Access"
ON storage.objects FOR SELECT
USING ( bucket_id = 'media' );

-- Policy to allow authenticated uploads
CREATE POLICY "Authenticated Uploads"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK ( bucket_id = 'media' );

-- Policy to allow owners to delete their own files (simplified for now, allowing auth users to delete)
CREATE POLICY "Authenticated Deletes"
ON storage.objects FOR DELETE
TO authenticated
USING ( bucket_id = 'media' );
-- Add columns for extended settings (Shipping, Taxes, Policies, Support)
ALTER TABLE store_config
ADD COLUMN IF NOT EXISTS support_email text,
ADD COLUMN IF NOT EXISTS shipping_rates jsonb DEFAULT '[{"id": "standard", "name": "Standard Shipping", "price": 0, "min_order": 0}]'::jsonb,
ADD COLUMN IF NOT EXISTS tax_rate numeric DEFAULT 0,
ADD COLUMN IF NOT EXISTS policy_refund text,
ADD COLUMN IF NOT EXISTS policy_privacy text,
ADD COLUMN IF NOT EXISTS policy_terms text;
ALTER TABLE store_config
ADD COLUMN IF NOT EXISTS store_address JSONB DEFAULT '{}'::jsonb,
ADD COLUMN IF NOT EXISTS store_formats JSONB DEFAULT '{"timezone": "UTC", "weight_unit": "kg", "dimension_unit": "cm"}'::jsonb,
ADD COLUMN IF NOT EXISTS shipping_zones JSONB DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS tax_regions JSONB DEFAULT '[]'::jsonb,
ADD COLUMN IF NOT EXISTS notification_settings JSONB DEFAULT '{}'::jsonb;

-- Add shipping secrets to store_secrets
ALTER TABLE store_secrets
ADD COLUMN IF NOT EXISTS shippo_api_key text,
ADD COLUMN IF NOT EXISTS easypost_api_key text;

-- Add shipping provider selection to store_config
ALTER TABLE store_config
ADD COLUMN IF NOT EXISTS shipping_provider text DEFAULT 'manual'; -- 'manual', 'shippo', 'easypost'

-- Add fulfillment columns to orders table
ALTER TABLE orders
ADD COLUMN IF NOT EXISTS tracking_number text,
ADD COLUMN IF NOT EXISTS carrier text,
ADD COLUMN IF NOT EXISTS shipped_at timestamptz;
-- Update decrement_stock to handle variants
create or replace function decrement_stock(product_id uuid, quantity_to_decrement integer, variant_id text default null)
returns void
language plpgsql
security definer
as $$
begin
  if variant_id is not null then
    -- Update variant stock in JSONB
    update products
    set variants = (
      select jsonb_agg(
        case
          when (item->>'id') = variant_id then
            jsonb_set(item, '{stock}', to_jsonb(GREATEST(0, (item->>'stock')::int - quantity_to_decrement)))
          else
            item
        end
      )
      from jsonb_array_elements(variants) as item
    )
    where id = product_id;
    
    -- Also decrement parent stock
    update products
    set stock = GREATEST(0, stock - quantity_to_decrement)
    where id = product_id;
    
  else
    -- Standard decrement
    update products
    set stock = stock - quantity_to_decrement
    where id = product_id
    and stock >= quantity_to_decrement;
  end if;
end;
$$;
alter table order_items
add column variant_id text,
add column variant_title text;
create table if not exists domains (
  id uuid default gen_random_uuid() primary key,
  store_id uuid references stores(id) on delete cascade not null,
  domain text unique not null,
  status text default 'pending' check (status in ('pending', 'active', 'error')),
  verified_at timestamptz,
  created_at timestamptz default now()
);

-- RLS Policies
alter table domains enable row level security;

-- Public read access (needed for domain resolution)
create policy "Domains are viewable by everyone" 
  on domains for select 
  using (true);

-- Store owners can manage their domains
create policy "Store owners can manage their domains" 
  on domains for all 
  using (
    store_id in (
      select store_id from profiles 
      where id = auth.uid()
    )
  );
-- Function to create a new tenant (store) for a user
-- This function is SECURITY DEFINER to bypass RLS on stores/profiles during creation
create or replace function create_tenant(
  store_name text,
  store_slug text
) returns uuid
language plpgsql
security definer
as $$
declare
  new_store_id uuid;
  user_id uuid;
begin
  -- Get current user ID
  user_id := auth.uid();
  if user_id is null then
    raise exception 'Not authenticated';
  end if;

  -- Check if slug is taken
  if exists (select 1 from stores where slug = store_slug) then
    raise exception 'Store URL is already taken';
  end if;

  -- 1. Create Store
  insert into stores (name, slug)
  values (store_name, store_slug)
  returning id into new_store_id;

  -- 2. Create Profile (Link User to Store as Owner)
  -- Check if profile exists (it shouldn't for a new user, but handle upsert just in case)
  insert into profiles (id, store_id, role)
  values (user_id, new_store_id, 'owner')
  on conflict (id) do update
  set store_id = new_store_id, role = 'owner';

  -- 3. Create Default Store Config
  insert into store_config (
    store_id, 
    name, 
    currency, 
    header_style, 
    hero_style, 
    product_card_style, 
    footer_style,
    tax_regions
  )
  values (
    new_store_id,
    store_name,
    'USD',
    'minimal',
    'split',
    'minimal',
    'minimal',
    '[{"id": "us-tax", "country_code": "US", "region_code": "*", "rate": 0, "name": "Sales Tax"}]'::jsonb
  );

  -- 4. Create Free Subscription
  insert into subscriptions (
    store_id,
    plan_id,
    status,
    current_period_start,
    current_period_end
  )
  values (
    new_store_id,
    'free',
    'trialing',
    now(),
    now() + interval '14 days'
  );

  return new_store_id;
end;
$$;
-- Fix store_config Primary Key issue
-- The original table had 'id' as PK with default 1, which prevents multiple tenants from being created.

-- 1. Remove legacy default config that has no store_id
delete from store_config where store_id is null;

-- 2. Drop the old Primary Key and ID column
alter table store_config drop constraint if exists store_config_pkey;
alter table store_config drop column if exists id;

-- 3. Make store_id the new Primary Key
alter table store_config add primary key (store_id);

-- 4. Ensure RLS is enabled (just in case)
alter table store_config enable row level security;
